// Code generated by protoc-gen-go.
// source: ca.proto
// DO NOT EDIT!

/*
Package protos is a generated protocol buffer package.

It is generated from these files:
	ca.proto

It has these top-level messages:
	CAStatus
	Identity
	Password
	PublicKey
	PrivateKey
	Signature
	ECertCreateReq
	ECertReadReq
	ECertRevokeReq
	ECertCRLReq
	TCertCreateReq
	TCertCreateSetReq
	TCertReadReq
	TCertReadSetReq
	TCertRevokeReq
	TCertRevokeSetReq
	TCertCRLReq
	TLSCertCreateReq
	TLSCertReadReq
	TLSCertRevokeReq
	Cert
	CertSet
	Creds
*/
package protos

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "google/protobuf"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Public/private keys.
//
type CryptoType int32

const (
	CryptoType_ECDSA CryptoType = 0
	CryptoType_RSA   CryptoType = 1
	CryptoType_DSA   CryptoType = 2
)

var CryptoType_name = map[int32]string{
	0: "ECDSA",
	1: "RSA",
	2: "DSA",
}
var CryptoType_value = map[string]int32{
	"ECDSA": 0,
	"RSA":   1,
	"DSA":   2,
}

func (x CryptoType) String() string {
	return proto.EnumName(CryptoType_name, int32(x))
}

type CAStatus_StatusCode int32

const (
	CAStatus_OK            CAStatus_StatusCode = 0
	CAStatus_UNKNOWN_ERROR CAStatus_StatusCode = 1
)

var CAStatus_StatusCode_name = map[int32]string{
	0: "OK",
	1: "UNKNOWN_ERROR",
}
var CAStatus_StatusCode_value = map[string]int32{
	"OK":            0,
	"UNKNOWN_ERROR": 1,
}

func (x CAStatus_StatusCode) String() string {
	return proto.EnumName(CAStatus_StatusCode_name, int32(x))
}

// Status codes shared by both CAs.
//
type CAStatus struct {
	Status CAStatus_StatusCode `protobuf:"varint,1,opt,name=status,enum=protos.CAStatus_StatusCode" json:"status,omitempty"`
}

func (m *CAStatus) Reset()         { *m = CAStatus{} }
func (m *CAStatus) String() string { return proto.CompactTextString(m) }
func (*CAStatus) ProtoMessage()    {}

// Uniquely identifies a user towards either CA.
//
type Identity struct {
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
}

func (m *Identity) Reset()         { *m = Identity{} }
func (m *Identity) String() string { return proto.CompactTextString(m) }
func (*Identity) ProtoMessage()    {}

type Password struct {
	Pw string `protobuf:"bytes,1,opt,name=pw" json:"pw,omitempty"`
}

func (m *Password) Reset()         { *m = Password{} }
func (m *Password) String() string { return proto.CompactTextString(m) }
func (*Password) ProtoMessage()    {}

type PublicKey struct {
	Type CryptoType `protobuf:"varint,1,opt,name=type,enum=protos.CryptoType" json:"type,omitempty"`
	Key  []byte     `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *PublicKey) Reset()         { *m = PublicKey{} }
func (m *PublicKey) String() string { return proto.CompactTextString(m) }
func (*PublicKey) ProtoMessage()    {}

type PrivateKey struct {
	Type CryptoType `protobuf:"varint,1,opt,name=type,enum=protos.CryptoType" json:"type,omitempty"`
	Key  []byte     `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *PrivateKey) Reset()         { *m = PrivateKey{} }
func (m *PrivateKey) String() string { return proto.CompactTextString(m) }
func (*PrivateKey) ProtoMessage()    {}

// Signature.
//
type Signature struct {
	Type CryptoType `protobuf:"varint,1,opt,name=type,enum=protos.CryptoType" json:"type,omitempty"`
	R    []byte     `protobuf:"bytes,2,opt,name=r,proto3" json:"r,omitempty"`
	S    []byte     `protobuf:"bytes,3,opt,name=s,proto3" json:"s,omitempty"`
}

func (m *Signature) Reset()         { *m = Signature{} }
func (m *Signature) String() string { return proto.CompactTextString(m) }
func (*Signature) ProtoMessage()    {}

// Certificate requests.
//
type ECertCreateReq struct {
	Ts  *google_protobuf.Timestamp `protobuf:"bytes,1,opt,name=ts" json:"ts,omitempty"`
	Id  *Identity                  `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
	Pw  *Password                  `protobuf:"bytes,3,opt,name=pw" json:"pw,omitempty"`
	Pub *PublicKey                 `protobuf:"bytes,4,opt,name=pub" json:"pub,omitempty"`
	Sig *Signature                 `protobuf:"bytes,5,opt,name=sig" json:"sig,omitempty"`
}

func (m *ECertCreateReq) Reset()         { *m = ECertCreateReq{} }
func (m *ECertCreateReq) String() string { return proto.CompactTextString(m) }
func (*ECertCreateReq) ProtoMessage()    {}

func (m *ECertCreateReq) GetTs() *google_protobuf.Timestamp {
	if m != nil {
		return m.Ts
	}
	return nil
}

func (m *ECertCreateReq) GetId() *Identity {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *ECertCreateReq) GetPw() *Password {
	if m != nil {
		return m.Pw
	}
	return nil
}

func (m *ECertCreateReq) GetPub() *PublicKey {
	if m != nil {
		return m.Pub
	}
	return nil
}

func (m *ECertCreateReq) GetSig() *Signature {
	if m != nil {
		return m.Sig
	}
	return nil
}

type ECertReadReq struct {
	Id   *Identity `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Hash []byte    `protobuf:"bytes,2,opt,name=hash,proto3" json:"hash,omitempty"`
}

func (m *ECertReadReq) Reset()         { *m = ECertReadReq{} }
func (m *ECertReadReq) String() string { return proto.CompactTextString(m) }
func (*ECertReadReq) ProtoMessage()    {}

func (m *ECertReadReq) GetId() *Identity {
	if m != nil {
		return m.Id
	}
	return nil
}

type ECertRevokeReq struct {
	Id   *Identity  `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Cert *Cert      `protobuf:"bytes,2,opt,name=cert" json:"cert,omitempty"`
	Sig  *Signature `protobuf:"bytes,3,opt,name=sig" json:"sig,omitempty"`
}

func (m *ECertRevokeReq) Reset()         { *m = ECertRevokeReq{} }
func (m *ECertRevokeReq) String() string { return proto.CompactTextString(m) }
func (*ECertRevokeReq) ProtoMessage()    {}

func (m *ECertRevokeReq) GetId() *Identity {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *ECertRevokeReq) GetCert() *Cert {
	if m != nil {
		return m.Cert
	}
	return nil
}

func (m *ECertRevokeReq) GetSig() *Signature {
	if m != nil {
		return m.Sig
	}
	return nil
}

type ECertCRLReq struct {
	Id  *Identity  `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Sig *Signature `protobuf:"bytes,2,opt,name=sig" json:"sig,omitempty"`
}

func (m *ECertCRLReq) Reset()         { *m = ECertCRLReq{} }
func (m *ECertCRLReq) String() string { return proto.CompactTextString(m) }
func (*ECertCRLReq) ProtoMessage()    {}

func (m *ECertCRLReq) GetId() *Identity {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *ECertCRLReq) GetSig() *Signature {
	if m != nil {
		return m.Sig
	}
	return nil
}

type TCertCreateReq struct {
	Ts  *google_protobuf.Timestamp `protobuf:"bytes,1,opt,name=ts" json:"ts,omitempty"`
	Id  *Identity                  `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
	Pub *PublicKey                 `protobuf:"bytes,3,opt,name=pub" json:"pub,omitempty"`
	Sig *Signature                 `protobuf:"bytes,4,opt,name=sig" json:"sig,omitempty"`
}

func (m *TCertCreateReq) Reset()         { *m = TCertCreateReq{} }
func (m *TCertCreateReq) String() string { return proto.CompactTextString(m) }
func (*TCertCreateReq) ProtoMessage()    {}

func (m *TCertCreateReq) GetTs() *google_protobuf.Timestamp {
	if m != nil {
		return m.Ts
	}
	return nil
}

func (m *TCertCreateReq) GetId() *Identity {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *TCertCreateReq) GetPub() *PublicKey {
	if m != nil {
		return m.Pub
	}
	return nil
}

func (m *TCertCreateReq) GetSig() *Signature {
	if m != nil {
		return m.Sig
	}
	return nil
}

type TCertCreateSetReq struct {
	Ts  *google_protobuf.Timestamp `protobuf:"bytes,1,opt,name=ts" json:"ts,omitempty"`
	Id  *Identity                  `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
	Num uint32                     `protobuf:"varint,3,opt,name=num" json:"num,omitempty"`
	Sig *Signature                 `protobuf:"bytes,4,opt,name=sig" json:"sig,omitempty"`
}

func (m *TCertCreateSetReq) Reset()         { *m = TCertCreateSetReq{} }
func (m *TCertCreateSetReq) String() string { return proto.CompactTextString(m) }
func (*TCertCreateSetReq) ProtoMessage()    {}

func (m *TCertCreateSetReq) GetTs() *google_protobuf.Timestamp {
	if m != nil {
		return m.Ts
	}
	return nil
}

func (m *TCertCreateSetReq) GetId() *Identity {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *TCertCreateSetReq) GetSig() *Signature {
	if m != nil {
		return m.Sig
	}
	return nil
}

type TCertReadReq struct {
	Ts  *google_protobuf.Timestamp `protobuf:"bytes,1,opt,name=ts" json:"ts,omitempty"`
	Id  *Identity                  `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
	Sig *Signature                 `protobuf:"bytes,3,opt,name=sig" json:"sig,omitempty"`
}

func (m *TCertReadReq) Reset()         { *m = TCertReadReq{} }
func (m *TCertReadReq) String() string { return proto.CompactTextString(m) }
func (*TCertReadReq) ProtoMessage()    {}

func (m *TCertReadReq) GetTs() *google_protobuf.Timestamp {
	if m != nil {
		return m.Ts
	}
	return nil
}

func (m *TCertReadReq) GetId() *Identity {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *TCertReadReq) GetSig() *Signature {
	if m != nil {
		return m.Sig
	}
	return nil
}

type TCertReadSetReq struct {
	Ts  *google_protobuf.Timestamp `protobuf:"bytes,1,opt,name=ts" json:"ts,omitempty"`
	Id  *Identity                  `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
	Num uint32                     `protobuf:"varint,3,opt,name=num" json:"num,omitempty"`
	Sig *Signature                 `protobuf:"bytes,4,opt,name=sig" json:"sig,omitempty"`
}

func (m *TCertReadSetReq) Reset()         { *m = TCertReadSetReq{} }
func (m *TCertReadSetReq) String() string { return proto.CompactTextString(m) }
func (*TCertReadSetReq) ProtoMessage()    {}

func (m *TCertReadSetReq) GetTs() *google_protobuf.Timestamp {
	if m != nil {
		return m.Ts
	}
	return nil
}

func (m *TCertReadSetReq) GetId() *Identity {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *TCertReadSetReq) GetSig() *Signature {
	if m != nil {
		return m.Sig
	}
	return nil
}

type TCertRevokeReq struct {
	Id   *Identity  `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Cert *Cert      `protobuf:"bytes,2,opt,name=cert" json:"cert,omitempty"`
	Sig  *Signature `protobuf:"bytes,3,opt,name=sig" json:"sig,omitempty"`
}

func (m *TCertRevokeReq) Reset()         { *m = TCertRevokeReq{} }
func (m *TCertRevokeReq) String() string { return proto.CompactTextString(m) }
func (*TCertRevokeReq) ProtoMessage()    {}

func (m *TCertRevokeReq) GetId() *Identity {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *TCertRevokeReq) GetCert() *Cert {
	if m != nil {
		return m.Cert
	}
	return nil
}

func (m *TCertRevokeReq) GetSig() *Signature {
	if m != nil {
		return m.Sig
	}
	return nil
}

type TCertRevokeSetReq struct {
	Id  *Identity                  `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Ts  *google_protobuf.Timestamp `protobuf:"bytes,2,opt,name=ts" json:"ts,omitempty"`
	Sig *Signature                 `protobuf:"bytes,3,opt,name=sig" json:"sig,omitempty"`
}

func (m *TCertRevokeSetReq) Reset()         { *m = TCertRevokeSetReq{} }
func (m *TCertRevokeSetReq) String() string { return proto.CompactTextString(m) }
func (*TCertRevokeSetReq) ProtoMessage()    {}

func (m *TCertRevokeSetReq) GetId() *Identity {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *TCertRevokeSetReq) GetTs() *google_protobuf.Timestamp {
	if m != nil {
		return m.Ts
	}
	return nil
}

func (m *TCertRevokeSetReq) GetSig() *Signature {
	if m != nil {
		return m.Sig
	}
	return nil
}

type TCertCRLReq struct {
	Id  *Identity  `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Sig *Signature `protobuf:"bytes,2,opt,name=sig" json:"sig,omitempty"`
}

func (m *TCertCRLReq) Reset()         { *m = TCertCRLReq{} }
func (m *TCertCRLReq) String() string { return proto.CompactTextString(m) }
func (*TCertCRLReq) ProtoMessage()    {}

func (m *TCertCRLReq) GetId() *Identity {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *TCertCRLReq) GetSig() *Signature {
	if m != nil {
		return m.Sig
	}
	return nil
}

// TLSCA Certificate requests.
//
type TLSCertCreateReq struct {
	Timestamp *google_protobuf.Timestamp `protobuf:"bytes,1,opt,name=timestamp" json:"timestamp,omitempty"`
	Id        *Identity                  `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
	Pw        *Password                  `protobuf:"bytes,3,opt,name=pw" json:"pw,omitempty"`
	Pub       *PublicKey                 `protobuf:"bytes,4,opt,name=pub" json:"pub,omitempty"`
	Sig       *Signature                 `protobuf:"bytes,5,opt,name=sig" json:"sig,omitempty"`
}

func (m *TLSCertCreateReq) Reset()         { *m = TLSCertCreateReq{} }
func (m *TLSCertCreateReq) String() string { return proto.CompactTextString(m) }
func (*TLSCertCreateReq) ProtoMessage()    {}

func (m *TLSCertCreateReq) GetTimestamp() *google_protobuf.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

func (m *TLSCertCreateReq) GetId() *Identity {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *TLSCertCreateReq) GetPw() *Password {
	if m != nil {
		return m.Pw
	}
	return nil
}

func (m *TLSCertCreateReq) GetPub() *PublicKey {
	if m != nil {
		return m.Pub
	}
	return nil
}

func (m *TLSCertCreateReq) GetSig() *Signature {
	if m != nil {
		return m.Sig
	}
	return nil
}

type TLSCertReadReq struct {
	Id   *Identity `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Hash []byte    `protobuf:"bytes,2,opt,name=hash,proto3" json:"hash,omitempty"`
}

func (m *TLSCertReadReq) Reset()         { *m = TLSCertReadReq{} }
func (m *TLSCertReadReq) String() string { return proto.CompactTextString(m) }
func (*TLSCertReadReq) ProtoMessage()    {}

func (m *TLSCertReadReq) GetId() *Identity {
	if m != nil {
		return m.Id
	}
	return nil
}

type TLSCertRevokeReq struct {
	Id   *Identity  `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Cert *Cert      `protobuf:"bytes,2,opt,name=cert" json:"cert,omitempty"`
	Sig  *Signature `protobuf:"bytes,3,opt,name=sig" json:"sig,omitempty"`
}

func (m *TLSCertRevokeReq) Reset()         { *m = TLSCertRevokeReq{} }
func (m *TLSCertRevokeReq) String() string { return proto.CompactTextString(m) }
func (*TLSCertRevokeReq) ProtoMessage()    {}

func (m *TLSCertRevokeReq) GetId() *Identity {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *TLSCertRevokeReq) GetCert() *Cert {
	if m != nil {
		return m.Cert
	}
	return nil
}

func (m *TLSCertRevokeReq) GetSig() *Signature {
	if m != nil {
		return m.Sig
	}
	return nil
}

// Certificate issued by either the ECA or TCA.
//
type Cert struct {
	Cert []byte `protobuf:"bytes,1,opt,name=cert,proto3" json:"cert,omitempty"`
}

func (m *Cert) Reset()         { *m = Cert{} }
func (m *Cert) String() string { return proto.CompactTextString(m) }
func (*Cert) ProtoMessage()    {}

type CertSet struct {
	Key   []byte   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Certs [][]byte `protobuf:"bytes,2,rep,name=certs,proto3" json:"certs,omitempty"`
}

func (m *CertSet) Reset()         { *m = CertSet{} }
func (m *CertSet) String() string { return proto.CompactTextString(m) }
func (*CertSet) ProtoMessage()    {}

type Creds struct {
	Cert *Cert  `protobuf:"bytes,1,opt,name=cert" json:"cert,omitempty"`
	Key  []byte `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *Creds) Reset()         { *m = Creds{} }
func (m *Creds) String() string { return proto.CompactTextString(m) }
func (*Creds) ProtoMessage()    {}

func (m *Creds) GetCert() *Cert {
	if m != nil {
		return m.Cert
	}
	return nil
}

func init() {
	proto.RegisterEnum("protos.CryptoType", CryptoType_name, CryptoType_value)
	proto.RegisterEnum("protos.CAStatus_StatusCode", CAStatus_StatusCode_name, CAStatus_StatusCode_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Client API for ECAP service

type ECAPClient interface {
	CreateCertificate(ctx context.Context, in *ECertCreateReq, opts ...grpc.CallOption) (*Creds, error)
	ReadCertificate(ctx context.Context, in *ECertReadReq, opts ...grpc.CallOption) (*Cert, error)
	RevokeCertificate(ctx context.Context, in *ECertRevokeReq, opts ...grpc.CallOption) (*CAStatus, error)
}

type eCAPClient struct {
	cc *grpc.ClientConn
}

func NewECAPClient(cc *grpc.ClientConn) ECAPClient {
	return &eCAPClient{cc}
}

func (c *eCAPClient) CreateCertificate(ctx context.Context, in *ECertCreateReq, opts ...grpc.CallOption) (*Creds, error) {
	out := new(Creds)
	err := grpc.Invoke(ctx, "/protos.ECAP/CreateCertificate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eCAPClient) ReadCertificate(ctx context.Context, in *ECertReadReq, opts ...grpc.CallOption) (*Cert, error) {
	out := new(Cert)
	err := grpc.Invoke(ctx, "/protos.ECAP/ReadCertificate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eCAPClient) RevokeCertificate(ctx context.Context, in *ECertRevokeReq, opts ...grpc.CallOption) (*CAStatus, error) {
	out := new(CAStatus)
	err := grpc.Invoke(ctx, "/protos.ECAP/RevokeCertificate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ECAP service

type ECAPServer interface {
	CreateCertificate(context.Context, *ECertCreateReq) (*Creds, error)
	ReadCertificate(context.Context, *ECertReadReq) (*Cert, error)
	RevokeCertificate(context.Context, *ECertRevokeReq) (*CAStatus, error)
}

func RegisterECAPServer(s *grpc.Server, srv ECAPServer) {
	s.RegisterService(&_ECAP_serviceDesc, srv)
}

func _ECAP_CreateCertificate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ECertCreateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ECAPServer).CreateCertificate(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _ECAP_ReadCertificate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ECertReadReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ECAPServer).ReadCertificate(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _ECAP_RevokeCertificate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ECertRevokeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ECAPServer).RevokeCertificate(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _ECAP_serviceDesc = grpc.ServiceDesc{
	ServiceName: "protos.ECAP",
	HandlerType: (*ECAPServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateCertificate",
			Handler:    _ECAP_CreateCertificate_Handler,
		},
		{
			MethodName: "ReadCertificate",
			Handler:    _ECAP_ReadCertificate_Handler,
		},
		{
			MethodName: "RevokeCertificate",
			Handler:    _ECAP_RevokeCertificate_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for ECAA service

type ECAAClient interface {
	RegisterUser(ctx context.Context, in *Identity, opts ...grpc.CallOption) (*Password, error)
	RevokeCertificate(ctx context.Context, in *ECertRevokeReq, opts ...grpc.CallOption) (*CAStatus, error)
	CreateCRL(ctx context.Context, in *ECertCRLReq, opts ...grpc.CallOption) (*CAStatus, error)
}

type eCAAClient struct {
	cc *grpc.ClientConn
}

func NewECAAClient(cc *grpc.ClientConn) ECAAClient {
	return &eCAAClient{cc}
}

func (c *eCAAClient) RegisterUser(ctx context.Context, in *Identity, opts ...grpc.CallOption) (*Password, error) {
	out := new(Password)
	err := grpc.Invoke(ctx, "/protos.ECAA/RegisterUser", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eCAAClient) RevokeCertificate(ctx context.Context, in *ECertRevokeReq, opts ...grpc.CallOption) (*CAStatus, error) {
	out := new(CAStatus)
	err := grpc.Invoke(ctx, "/protos.ECAA/RevokeCertificate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eCAAClient) CreateCRL(ctx context.Context, in *ECertCRLReq, opts ...grpc.CallOption) (*CAStatus, error) {
	out := new(CAStatus)
	err := grpc.Invoke(ctx, "/protos.ECAA/CreateCRL", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ECAA service

type ECAAServer interface {
	RegisterUser(context.Context, *Identity) (*Password, error)
	RevokeCertificate(context.Context, *ECertRevokeReq) (*CAStatus, error)
	CreateCRL(context.Context, *ECertCRLReq) (*CAStatus, error)
}

func RegisterECAAServer(s *grpc.Server, srv ECAAServer) {
	s.RegisterService(&_ECAA_serviceDesc, srv)
}

func _ECAA_RegisterUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(Identity)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ECAAServer).RegisterUser(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _ECAA_RevokeCertificate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ECertRevokeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ECAAServer).RevokeCertificate(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _ECAA_CreateCRL_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ECertCRLReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ECAAServer).CreateCRL(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _ECAA_serviceDesc = grpc.ServiceDesc{
	ServiceName: "protos.ECAA",
	HandlerType: (*ECAAServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterUser",
			Handler:    _ECAA_RegisterUser_Handler,
		},
		{
			MethodName: "RevokeCertificate",
			Handler:    _ECAA_RevokeCertificate_Handler,
		},
		{
			MethodName: "CreateCRL",
			Handler:    _ECAA_CreateCRL_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for TCAP service

type TCAPClient interface {
	CreateCertificate(ctx context.Context, in *TCertCreateReq, opts ...grpc.CallOption) (*Cert, error)
	CreateCertificateSet(ctx context.Context, in *TCertCreateSetReq, opts ...grpc.CallOption) (*CertSet, error)
	ReadCertificate(ctx context.Context, in *TCertReadReq, opts ...grpc.CallOption) (*Cert, error)
	ReadCertificateSet(ctx context.Context, in *TCertReadSetReq, opts ...grpc.CallOption) (*CertSet, error)
	RevokeCertificate(ctx context.Context, in *TCertRevokeReq, opts ...grpc.CallOption) (*CAStatus, error)
	RevokeCertificateSet(ctx context.Context, in *TCertRevokeSetReq, opts ...grpc.CallOption) (*CAStatus, error)
}

type tCAPClient struct {
	cc *grpc.ClientConn
}

func NewTCAPClient(cc *grpc.ClientConn) TCAPClient {
	return &tCAPClient{cc}
}

func (c *tCAPClient) CreateCertificate(ctx context.Context, in *TCertCreateReq, opts ...grpc.CallOption) (*Cert, error) {
	out := new(Cert)
	err := grpc.Invoke(ctx, "/protos.TCAP/CreateCertificate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tCAPClient) CreateCertificateSet(ctx context.Context, in *TCertCreateSetReq, opts ...grpc.CallOption) (*CertSet, error) {
	out := new(CertSet)
	err := grpc.Invoke(ctx, "/protos.TCAP/CreateCertificateSet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tCAPClient) ReadCertificate(ctx context.Context, in *TCertReadReq, opts ...grpc.CallOption) (*Cert, error) {
	out := new(Cert)
	err := grpc.Invoke(ctx, "/protos.TCAP/ReadCertificate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tCAPClient) ReadCertificateSet(ctx context.Context, in *TCertReadSetReq, opts ...grpc.CallOption) (*CertSet, error) {
	out := new(CertSet)
	err := grpc.Invoke(ctx, "/protos.TCAP/ReadCertificateSet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tCAPClient) RevokeCertificate(ctx context.Context, in *TCertRevokeReq, opts ...grpc.CallOption) (*CAStatus, error) {
	out := new(CAStatus)
	err := grpc.Invoke(ctx, "/protos.TCAP/RevokeCertificate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tCAPClient) RevokeCertificateSet(ctx context.Context, in *TCertRevokeSetReq, opts ...grpc.CallOption) (*CAStatus, error) {
	out := new(CAStatus)
	err := grpc.Invoke(ctx, "/protos.TCAP/RevokeCertificateSet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for TCAP service

type TCAPServer interface {
	CreateCertificate(context.Context, *TCertCreateReq) (*Cert, error)
	CreateCertificateSet(context.Context, *TCertCreateSetReq) (*CertSet, error)
	ReadCertificate(context.Context, *TCertReadReq) (*Cert, error)
	ReadCertificateSet(context.Context, *TCertReadSetReq) (*CertSet, error)
	RevokeCertificate(context.Context, *TCertRevokeReq) (*CAStatus, error)
	RevokeCertificateSet(context.Context, *TCertRevokeSetReq) (*CAStatus, error)
}

func RegisterTCAPServer(s *grpc.Server, srv TCAPServer) {
	s.RegisterService(&_TCAP_serviceDesc, srv)
}

func _TCAP_CreateCertificate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(TCertCreateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(TCAPServer).CreateCertificate(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _TCAP_CreateCertificateSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(TCertCreateSetReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(TCAPServer).CreateCertificateSet(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _TCAP_ReadCertificate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(TCertReadReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(TCAPServer).ReadCertificate(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _TCAP_ReadCertificateSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(TCertReadSetReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(TCAPServer).ReadCertificateSet(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _TCAP_RevokeCertificate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(TCertRevokeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(TCAPServer).RevokeCertificate(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _TCAP_RevokeCertificateSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(TCertRevokeSetReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(TCAPServer).RevokeCertificateSet(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _TCAP_serviceDesc = grpc.ServiceDesc{
	ServiceName: "protos.TCAP",
	HandlerType: (*TCAPServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateCertificate",
			Handler:    _TCAP_CreateCertificate_Handler,
		},
		{
			MethodName: "CreateCertificateSet",
			Handler:    _TCAP_CreateCertificateSet_Handler,
		},
		{
			MethodName: "ReadCertificate",
			Handler:    _TCAP_ReadCertificate_Handler,
		},
		{
			MethodName: "ReadCertificateSet",
			Handler:    _TCAP_ReadCertificateSet_Handler,
		},
		{
			MethodName: "RevokeCertificate",
			Handler:    _TCAP_RevokeCertificate_Handler,
		},
		{
			MethodName: "RevokeCertificateSet",
			Handler:    _TCAP_RevokeCertificateSet_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for TCAA service

type TCAAClient interface {
	RevokeCertificate(ctx context.Context, in *TCertRevokeReq, opts ...grpc.CallOption) (*CAStatus, error)
	RevokeCertificateSet(ctx context.Context, in *TCertRevokeSetReq, opts ...grpc.CallOption) (*CAStatus, error)
	CreateCRL(ctx context.Context, in *TCertCRLReq, opts ...grpc.CallOption) (*CAStatus, error)
}

type tCAAClient struct {
	cc *grpc.ClientConn
}

func NewTCAAClient(cc *grpc.ClientConn) TCAAClient {
	return &tCAAClient{cc}
}

func (c *tCAAClient) RevokeCertificate(ctx context.Context, in *TCertRevokeReq, opts ...grpc.CallOption) (*CAStatus, error) {
	out := new(CAStatus)
	err := grpc.Invoke(ctx, "/protos.TCAA/RevokeCertificate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tCAAClient) RevokeCertificateSet(ctx context.Context, in *TCertRevokeSetReq, opts ...grpc.CallOption) (*CAStatus, error) {
	out := new(CAStatus)
	err := grpc.Invoke(ctx, "/protos.TCAA/RevokeCertificateSet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tCAAClient) CreateCRL(ctx context.Context, in *TCertCRLReq, opts ...grpc.CallOption) (*CAStatus, error) {
	out := new(CAStatus)
	err := grpc.Invoke(ctx, "/protos.TCAA/CreateCRL", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for TCAA service

type TCAAServer interface {
	RevokeCertificate(context.Context, *TCertRevokeReq) (*CAStatus, error)
	RevokeCertificateSet(context.Context, *TCertRevokeSetReq) (*CAStatus, error)
	CreateCRL(context.Context, *TCertCRLReq) (*CAStatus, error)
}

func RegisterTCAAServer(s *grpc.Server, srv TCAAServer) {
	s.RegisterService(&_TCAA_serviceDesc, srv)
}

func _TCAA_RevokeCertificate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(TCertRevokeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(TCAAServer).RevokeCertificate(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _TCAA_RevokeCertificateSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(TCertRevokeSetReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(TCAAServer).RevokeCertificateSet(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _TCAA_CreateCRL_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(TCertCRLReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(TCAAServer).CreateCRL(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _TCAA_serviceDesc = grpc.ServiceDesc{
	ServiceName: "protos.TCAA",
	HandlerType: (*TCAAServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RevokeCertificate",
			Handler:    _TCAA_RevokeCertificate_Handler,
		},
		{
			MethodName: "RevokeCertificateSet",
			Handler:    _TCAA_RevokeCertificateSet_Handler,
		},
		{
			MethodName: "CreateCRL",
			Handler:    _TCAA_CreateCRL_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for TLSCAP service

type TLSCAPClient interface {
	CreateCertificate(ctx context.Context, in *TLSCertCreateReq, opts ...grpc.CallOption) (*Cert, error)
	ReadCertificate(ctx context.Context, in *TLSCertReadReq, opts ...grpc.CallOption) (*Cert, error)
	RevokeCertificate(ctx context.Context, in *TLSCertRevokeReq, opts ...grpc.CallOption) (*CAStatus, error)
}

type tLSCAPClient struct {
	cc *grpc.ClientConn
}

func NewTLSCAPClient(cc *grpc.ClientConn) TLSCAPClient {
	return &tLSCAPClient{cc}
}

func (c *tLSCAPClient) CreateCertificate(ctx context.Context, in *TLSCertCreateReq, opts ...grpc.CallOption) (*Cert, error) {
	out := new(Cert)
	err := grpc.Invoke(ctx, "/protos.TLSCAP/CreateCertificate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tLSCAPClient) ReadCertificate(ctx context.Context, in *TLSCertReadReq, opts ...grpc.CallOption) (*Cert, error) {
	out := new(Cert)
	err := grpc.Invoke(ctx, "/protos.TLSCAP/ReadCertificate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tLSCAPClient) RevokeCertificate(ctx context.Context, in *TLSCertRevokeReq, opts ...grpc.CallOption) (*CAStatus, error) {
	out := new(CAStatus)
	err := grpc.Invoke(ctx, "/protos.TLSCAP/RevokeCertificate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for TLSCAP service

type TLSCAPServer interface {
	CreateCertificate(context.Context, *TLSCertCreateReq) (*Cert, error)
	ReadCertificate(context.Context, *TLSCertReadReq) (*Cert, error)
	RevokeCertificate(context.Context, *TLSCertRevokeReq) (*CAStatus, error)
}

func RegisterTLSCAPServer(s *grpc.Server, srv TLSCAPServer) {
	s.RegisterService(&_TLSCAP_serviceDesc, srv)
}

func _TLSCAP_CreateCertificate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(TLSCertCreateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(TLSCAPServer).CreateCertificate(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _TLSCAP_ReadCertificate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(TLSCertReadReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(TLSCAPServer).ReadCertificate(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _TLSCAP_RevokeCertificate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(TLSCertRevokeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(TLSCAPServer).RevokeCertificate(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _TLSCAP_serviceDesc = grpc.ServiceDesc{
	ServiceName: "protos.TLSCAP",
	HandlerType: (*TLSCAPServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateCertificate",
			Handler:    _TLSCAP_CreateCertificate_Handler,
		},
		{
			MethodName: "ReadCertificate",
			Handler:    _TLSCAP_ReadCertificate_Handler,
		},
		{
			MethodName: "RevokeCertificate",
			Handler:    _TLSCAP_RevokeCertificate_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for TLSCAA service

type TLSCAAClient interface {
	RevokeCertificate(ctx context.Context, in *TLSCertRevokeReq, opts ...grpc.CallOption) (*CAStatus, error)
}

type tLSCAAClient struct {
	cc *grpc.ClientConn
}

func NewTLSCAAClient(cc *grpc.ClientConn) TLSCAAClient {
	return &tLSCAAClient{cc}
}

func (c *tLSCAAClient) RevokeCertificate(ctx context.Context, in *TLSCertRevokeReq, opts ...grpc.CallOption) (*CAStatus, error) {
	out := new(CAStatus)
	err := grpc.Invoke(ctx, "/protos.TLSCAA/RevokeCertificate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for TLSCAA service

type TLSCAAServer interface {
	RevokeCertificate(context.Context, *TLSCertRevokeReq) (*CAStatus, error)
}

func RegisterTLSCAAServer(s *grpc.Server, srv TLSCAAServer) {
	s.RegisterService(&_TLSCAA_serviceDesc, srv)
}

func _TLSCAA_RevokeCertificate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(TLSCertRevokeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(TLSCAAServer).RevokeCertificate(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _TLSCAA_serviceDesc = grpc.ServiceDesc{
	ServiceName: "protos.TLSCAA",
	HandlerType: (*TLSCAAServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RevokeCertificate",
			Handler:    _TLSCAA_RevokeCertificate_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}
